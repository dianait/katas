# Season Detector - Kata de ProgramaciÃ³n

Una librerÃ­a Swift para detectar automÃ¡ticamente la estaciÃ³n del aÃ±o basÃ¡ndose en una fecha dada.

> **Kata inspirada en el curso:** [Testing: Introduction and Best Practices](https://codely.com/en/courses/testing-introduction-and-best-practices-o9me) de *CodelyTV*

## ğŸ¯ Objetivo de la Kata

El objetivo principal es crear un caso de uso que determine si una fecha pertenece a una estaciÃ³n especÃ­fica. Si la fecha no pertenece a ninguna estaciÃ³n conocida, debe lanzar un error.

## ğŸ“‹ Requisitos

- âœ… Detectar la estaciÃ³n (primavera, verano, otoÃ±o, invierno) para cualquier fecha
- âœ… Lanzar error si la fecha no pertenece a ninguna estaciÃ³n
- âœ… Manejar correctamente el caso especial del invierno (que cruza el aÃ±o)
- âœ… Tests exhaustivos con fechas fijas y aleatorias

## ğŸ—ï¸ Arquitectura de la SoluciÃ³n

### Componentes Principales

#### 1. `Season` - Enum de Estaciones
```swift
enum Season: String {
    case spring, summer, autumn, winter
}
```

#### 2. `SeasonError` - Manejo de Errores
```swift
enum SeasonError: Error {
    case notFound
}
```

#### 3. `SeasonData` - Modelo de Datos
```swift
struct SeasonData {
    let season: Season
    let startMonth: Int
    let startDay: Int
    let endMonth: Int
    let endDay: Int
    
    // LÃ³gica de contenciÃ³n de fechas
    func contains(monthDay: Int) -> Bool
}
```

#### 4. `SeasonResolver` - Resolver Principal
```swift
struct SeasonResolver {
    func getSeason(from date: Date) throws -> Season
}
```

## ğŸ“… DefiniciÃ³n de Estaciones (Hemisferio Norte)

| EstaciÃ³n | Inicio | Fin |
|----------|--------|-----|
| **Primavera** | 21 Marzo | 20 Junio |
| **Verano** | 21 Junio | 20 Septiembre |
| **OtoÃ±o** | 21 Septiembre | 20 Diciembre |
| **Invierno** | 21 Diciembre | 20 Marzo (siguiente aÃ±o) |

## ğŸ§  Decisiones de DiseÃ±o

### 1. Â¿Por quÃ© `struct` en lugar de `class`?
- **Inmutabilidad**: Los datos de las estaciones no cambian
- **Eficiencia**: Mejor rendimiento en memoria
- **SemÃ¡ntica de valor**: Una estaciÃ³n representa un valor, no un objeto
- **Thread-safe**: Las structs son inherentemente seguras para concurrencia

### 2. Algoritmo de DetecciÃ³n
**ConversiÃ³n a valor numÃ©rico**: `mes * 100 + dÃ­a`
- Marzo 21 = 3 * 100 + 21 = 321
- Diciembre 25 = 12 * 100 + 25 = 1225

**Ventajas**:
- Comparaciones simples y eficientes
- No importa el aÃ±o
- FÃ¡cil de entender y mantener

### 3. Manejo del Invierno
El invierno es especial porque cruza el cambio de aÃ±o:
```swift
if season == .winter {
    return monthDay >= startValue || monthDay <= endValue
} else {
    return monthDay >= startValue && monthDay <= endValue
}
```

### 4. ExtracciÃ³n de NÃºmeros MÃ¡gicos
**Antes** (nÃºmeros mÃ¡gicos):
```swift
switch monthDay {
case 321...620: return .spring
case 621...920: return .summer
// ...
}
```

**DespuÃ©s** (datos estructurados):
```swift
let seasons: [SeasonData] = [
    SeasonData(season: .spring, startMonth: 3, startDay: 21, endMonth: 6, endDay: 20),
    // ...
]
```

## ğŸ§ª Estrategia de Testing

### Tests con Fechas Fijas
- **Fechas lÃ­mite**: Inicio y fin de cada estaciÃ³n
- **Fechas intermedias**: Puntos medios de cada estaciÃ³n
- **Edge cases**: VerificaciÃ³n de transiciones

### Tests con Fechas Aleatorias
Para hacer los tests mÃ¡s robustos, se extrajo la generaciÃ³n de fechas aleatorias a un archivo separado `RandomDateGenerator`:

#### Generador ExtraÃ­do (`RandomDateGenerator.swift`)
```swift
struct RandomDateGenerator {
    static func randomSpringDate() -> Date {
        let month = Int.random(in: 3...6)
        let day: Int
        switch month {
        case 3: day = Int.random(in: 21...31)
        case 4, 5: day = Int.random(in: 1...30)
        case 6: day = Int.random(in: 1...20)
        default: day = 15
        }
        return createDate(month: month, day: day)
    }
    // ... mÃ©todos similares para summer, autumn, winter
}
```

#### Ventajas de la ExtracciÃ³n
- **Reutilizable**: Otros tests pueden usar el mismo generador
- **Mantenible**: Cambios de lÃ³gica en un solo lugar
- **Limpieza**: Tests mÃ¡s enfocados y legibles
- **Single Responsibility**: SeparaciÃ³n clara de responsabilidades

#### Tests Implementados
- `testRandomSpringDates()`: 5 fechas aleatorias de primavera
- `testRandomSummerDates()`: 5 fechas aleatorias de verano
- `testRandomAutumnDates()`: 5 fechas aleatorias de otoÃ±o
- `testRandomWinterDates()`: 5 fechas aleatorias de invierno
- `testAllSeasonsInSingleTest()`: Test combinado con fechas fijas

## ğŸš€ Uso

```swift
let resolver = SeasonResolver()

do {
    let season = try resolver.getSeason(from: Date())
    print("EstaciÃ³n actual: \(season.rawValue)")
} catch SeasonError.notFound {
    print("No se pudo determinar la estaciÃ³n")
} catch {
    print("Error inesperado: \(error)")
}
```

## ğŸ“¦ InstalaciÃ³n

### Como LibrerÃ­a EstÃ¡tica en Xcode
1. Crear nuevo proyecto â†’ Static Library
2. AÃ±adir los archivos fuente
3. Crear target de tests para XCTest

### Estructura de Archivos
```
SeasonDetector/
â”œâ”€â”€ Sources/
â”‚   â”œâ”€â”€ Season.swift
â”‚   â”œâ”€â”€ SeasonData.swift
â”‚   â””â”€â”€ SeasonResolver.swift
â””â”€â”€ Tests/
    â”œâ”€â”€ SeasonResolverTests.swift
    â””â”€â”€ RandomDateGenerator.swift
```

## ğŸ”„ EvoluciÃ³n del CÃ³digo

### IteraciÃ³n 1: ImplementaciÃ³n BÃ¡sica
- Switch con nÃºmeros mÃ¡gicos
- LÃ³gica simple pero poco mantenible

### IteraciÃ³n 2: RefactorizaciÃ³n
- ExtracciÃ³n de datos a estructuras
- EliminaciÃ³n de nÃºmeros mÃ¡gicos
- Mejor separaciÃ³n de responsabilidades

### IteraciÃ³n 3: Tests Robustos y Refactoring
- ExtracciÃ³n del generador de fechas aleatorias a archivo separado
- Tests simplificados con 5 fechas aleatorias por estaciÃ³n
- Mejor organizaciÃ³n del cÃ³digo de testing
- Mantenimiento de tests fijos para casos lÃ­mite

## ğŸ¯ Aprendizajes Clave

1. **Refactoring progresivo**: Empezar simple y mejorar iterativamente
2. **EliminaciÃ³n de nÃºmeros mÃ¡gicos**: Hace el cÃ³digo mÃ¡s mantenible
3. **Tests aleatorios**: Complementan los tests fijos para mayor robustez
4. **SeparaciÃ³n de responsabilidades**: Extraer generadores a archivos separados
5. **Manejo de casos especiales**: El invierno requiere lÃ³gica particular
6. **DiseÃ±o de APIs**: Usar `throws` para casos de error claros

## ğŸ¤ ContribuciÃ³n

Esta kata demuestra buenas prÃ¡cticas de:
- DiseÃ±o de APIs en Swift
- Testing exhaustivo
- Refactoring de cÃ³digo legacy
- Manejo de casos edge
- DocumentaciÃ³n clara

---

*Kata desarrollada como ejercicio de programaciÃ³n y diseÃ±o de software en Swift, inspirada en el curso [Testing: Introduction and Best Practices](https://codely.com/en/courses/testing-introduction-and-best-practices-o9me) de Codely.*
